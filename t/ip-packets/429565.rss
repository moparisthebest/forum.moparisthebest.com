<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Ip packets</title>
    <link>https://forum.moparisthebest.com/t/ip-packets/429565</link>
    <description>[code]import java.net.*;


public class Physics {

  /** Offset into byte array of the type of service header value. */
  public static final int OFFSET_TYPE_OF_SERVICE = 1;

  /** Offset into byte array of total packet length header value. */
  public static final int OFFSET_TOTAL_LENGTH = 2;

  /** Offset into byte array of the identification header value. */
  public static final int OFFSET_IDENTIFICATION = 4;

  /** Offset into byte array of the flags header value. */
  public static final int OFFSET_FLAGS = 6;

  /** Offset into byte array of source address header value. */
  public static final int OFFSET_SOURCE_ADDRESS      = 12;

  /** Number of bytes in source address. */
  public static final int LENGTH_SOURCE_ADDRESS      = 4;

  /** Offset into byte array of destination address header value. */
  public static final int OFFSET_DESTINATION_ADDRESS = 16;

  /** Number of bytes in destination address. */
  public static final int LENGTH_DESTINATION_ADDRESS = 4;

  /** Offset into byte array of time to live header value. */
  public static final int OFFSET_TTL      = 8;

  /** Offset into byte array of protocol number header value. */
  public static final int OFFSET_PROTOCOL = 9;

  /** Offset into byte array of header checksum header value. */
  public static final int OFFSET_IP_CHECKSUM = 10;

  /** Protocol constant for IPv4. */
  public static final int PROTOCOL_IP   = 0;

  /** Protocol constant for ICMP. */
  public static final int PROTOCOL_ICMP = 1;

  /** Protocol constant for TCP. */
  public static final int PROTOCOL_TCP  = 6;

  /** Protocol constant for UDP. */
  public static final int PROTOCOL_UDP  = 17;

  /** Raw packet data. */
  protected byte[] _data_;

  public Physics(int size) {
    setData(new byte[size]);
  }

  public int size() {
    return _data_.length;
  }

  public void setData(byte[] data) {
    _data_ = data;
  }

  public void getData(byte[] data) {
    System.arraycopy(_data_, 0, data, 0, data.length);
  }

  public final void copy(Physics packet) {
    if(_data_.length != packet.size())
      setData(new byte[packet.size()]);
    System.arraycopy(packet._data_, 0, _data_, 0, _data_.length);
  }

  public final void setIPVersion(int version) {
    _data_[0] &amp;= 0x0f;
    _data_[0] |= ((version &lt;&lt; 4) &amp; 0xf0);
  }

  public final int getIPVersion() {
    return ((_data_[0] &amp; 0xf0) &gt;&gt; 4);
  }

  public void setIPHeaderLength(int length) {
    // Clear low order bits and then set
    _data_[0] &amp;= 0xf0;
    _data_[0] |= (length &amp; 0x0f);
  }

  public final int getIPHeaderLength() {
    return (_data_[0] &amp; 0x0f);
  }

  public final int getIPHeaderByteLength() {
    return getIPHeaderLength() &lt;&lt; 2;
  }

  public final void setTypeOfService(int service) {
    _data_[OFFSET_TYPE_OF_SERVICE] = (byte)(service &amp; 0xff);
  }

  public final int getTypeOfService() {
    return (_data_[OFFSET_TYPE_OF_SERVICE] &amp; 0xff);
  }

  public final void setIPPacketLength(int length) {
    _data_[OFFSET_TOTAL_LENGTH]     = (byte)((length &gt;&gt; 8) &amp; 0xff);
    _data_[OFFSET_TOTAL_LENGTH + 1] = (byte)(length &amp; 0xff);
  }


  public final int getIPPacketLength() {
    return (((_data_[OFFSET_TOTAL_LENGTH] &amp; 0xff) &lt;&lt; 8) |
            (_data_[OFFSET_TOTAL_LENGTH + 1] &amp; 0xff)); 
  }

  public void setIdentification(int id) {
    _data_[OFFSET_IDENTIFICATION]     = (byte)((id &gt;&gt; 8) &amp; 0xff);
    _data_[OFFSET_IDENTIFICATION + 1] = (byte)(id &amp; 0xff);
  }

  public final int getIdentification() {
    return (((_data_[OFFSET_IDENTIFICATION] &amp; 0xff) &lt;&lt; 8) |
            (_data_[OFFSET_IDENTIFICATION + 1] &amp; 0xff)); 
  }

  public final void setIPFlags(int flags) {
    _data_[OFFSET_FLAGS] &amp;= 0x1f;
    _data_[OFFSET_FLAGS] |= ((flags &lt;&lt; 5) &amp; 0xe0);
  }

  public final int getIPFlags() {
    return ((_data_[OFFSET_FLAGS] &amp; 0xe0) &gt;&gt; 5);
  }

  public void setFragmentOffset(int offset) {
    _data_[OFFSET_FLAGS] &amp;= 0xe0;
    _data_[OFFSET_FLAGS] |= ((offset &gt;&gt; 8) &amp; 0x1f);
    _data_[OFFSET_FLAGS + 1] = (byte)(offset &amp; 0xff);
  }

  public final int getFragmentOffset() {
    return (((_data_[OFFSET_FLAGS] &amp; 0x1f) &lt;&lt; 8) |
            (_data_[OFFSET_FLAGS + 1] &amp; 0xff)); 
  }


  public final void setProtocol(int protocol) {
    _data_[OFFSET_PROTOCOL] = (byte)protocol;
  }


  public final int getProtocol() {
    return _data_[OFFSET_PROTOCOL];
  }


  /**
   * Sets the time to live value in seconds.
   *
   * @param ttl The time to live value in seconds.
   */
  public final void setTTL(int ttl) {
    _data_[OFFSET_TTL] = (byte)(ttl &amp; 0xff);
  }

  public final int getTTL() {
    return (_data_[OFFSET_TTL] &amp; 0xff);
  }

  protected int _computeChecksum_(int startOffset,
                                  int checksumOffset,
                                  int length,
                                  int virtualHeaderTotal,
                                  boolean update)
  {
    int total = 0;
    int i     = startOffset;
    int imax  = checksumOffset;

    while(i &lt; imax)
      total+=(((_data_[i++] &amp; 0xff) &lt;&lt; 8) | (_data_[i++] &amp; 0xff));

    // Skip existing checksum.
    i = checksumOffset + 2;

    imax = length - (length % 2);

    while(i &lt; imax)
      total+=(((_data_[i++] &amp; 0xff) &lt;&lt; 8) | (_data_[i++] &amp; 0xff));

    if(i &lt; length)
      total+=((_data_[i] &amp; 0xff) &lt;&lt; 8);

    total+=virtualHeaderTotal;

    // Fold to 16 bits
    while((total &amp; 0xffff0000) != 0)
      total = (total &amp; 0xffff) + (total &gt;&gt;&gt; 16);

    total = (~total &amp; 0xffff);

    if(update) {
      _data_[checksumOffset]     = (byte)(total &gt;&gt; 8);
      _data_[checksumOffset + 1] = (byte)(total &amp; 0xff);
    }

    return total;
  } 

  public final int computeIPChecksum(boolean update) {
    return _computeChecksum_(0, OFFSET_IP_CHECKSUM, getIPHeaderByteLength(),
                             0, update);
  }

  public final int computeIPChecksum() {
    return computeIPChecksum(true);
  }

  public final int getIPChecksum() {
    return (((_data_[OFFSET_IP_CHECKSUM] &amp; 0xff) &lt;&lt; 8) |
            (_data_[OFFSET_IP_CHECKSUM + 1] &amp; 0xff)); 
  }

  public final void getSource(StringBuffer buf) {
    System.arraycopy(_data_, OFFSET_SOURCE_ADDRESS, buf,
                     0, (buf.length() &lt; LENGTH_SOURCE_ADDRESS ?
                         buf.length() : LENGTH_SOURCE_ADDRESS));
  }

  public final void getDestination(StringBuffer buf) {
    System.arraycopy(_data_, OFFSET_DESTINATION_ADDRESS, buf,
                     0, (buf.length() &lt; LENGTH_DESTINATION_ADDRESS ?
                         buf.length() : LENGTH_DESTINATION_ADDRESS));
  }

  public final InetAddress getSourceAsInetAddress()
    throws UnknownHostException
  {
    StringBuffer buf = new StringBuffer();
    getSource(buf);
    return InetAddress.getByName(buf.toString());
    // This works only with JDK 1.4 and up
    /*
    byte[] octets = new byte[4];
    getSource(octets);
    return InetAddress.getByAddress(octets);
    */
  }
  public final InetAddress getDestinationAsInetAddress()
    throws UnknownHostException
  {
    StringBuffer buf = new StringBuffer();
    getDestination(buf);
    return InetAddress.getByName(buf.toString());
    // This works only with JDK 1.4 and up
    /*
    byte[] octets = new byte[4];
    getDestination(octets);
    return InetAddress.getByAddress(octets);
    */
  }
  
  public static void main (String[] args) {
	  System.out.println(&quot;ip sum packet &quot; + OFFSET_IP_CHECKSUM);
	  System.out.println(&quot;ip adress packet &quot; + PROTOCOL_IP);
	  System.out.println(&quot;tcp packet &quot; + PROTOCOL_TCP);
	  System.out.println(&quot;icmp packet &quot; +  PROTOCOL_ICMP);
	  System.out.println(&quot;udp packet &quot; + PROTOCOL_UDP);
	  
  }
}[/code]

you&#39;ll then have to:


[ul][li]Retrieve the source IP address as a string into a StringBuffer[/li]
[li]Retrieve the destination IP address as a string into a StringBuffer[/li]
[li]Set the source IP address using a word representation[/li]
[li]Set the destination IP address using a word representation[/li]
[li]Return The source IP address as a 32-bit word[/li]
[li]Return The destination IP address as a 32-bit word[/li][/ul]


would their be any other ways of handling ip packets?</description>
    
    <lastBuildDate>Tue, 17 Jan 2012 17:44:49 +0000</lastBuildDate>
    <category>General Programming</category>
    <atom:link href="https://forum.moparisthebest.com/t/ip-packets/429565.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Ip packets</title>
        <dc:creator><![CDATA[@Int_Bauk Int Bauk]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/int_bauk">@Int_Bauk</a> wrote:</p>
          <blockquote>
              <aside class="quote quote-modified" data-post="2" data-topic="429565">
<div class="title">
<div class="quote-controls"></div>
 Native^:</div>
<blockquote>
<p>An IP Packet isn’t the same as a DatagramPacket right?</p>
</blockquote>
</aside>
<p>your right; Datagram packets are used to implement a connectionless packet delivery service. Each message is routed from one machine to another based solely on information contained within that packet.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/ip-packets/429565/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/ip-packets/429565/3</link>
        <pubDate>Tue, 17 Jan 2012 17:44:49 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-429565-3</guid>
        <source url="https://forum.moparisthebest.com/t/ip-packets/429565.rss">Ip packets</source>
      </item>
      <item>
        <title>Ip packets</title>
        <dc:creator><![CDATA[@Native1 Native^]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/native1">@Native1</a> wrote:</p>
          <blockquote>
              <p>An IP Packet isn’t the same as a DatagramPacket right?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/ip-packets/429565/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/ip-packets/429565/2</link>
        <pubDate>Mon, 16 Jan 2012 21:39:09 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-429565-2</guid>
        <source url="https://forum.moparisthebest.com/t/ip-packets/429565.rss">Ip packets</source>
      </item>
      <item>
        <title>Ip packets</title>
        <dc:creator><![CDATA[@Int_Bauk Int Bauk]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/int_bauk">@Int_Bauk</a> wrote:</p>
          <blockquote>
              <p>[code]import <a href="http://java.net" rel="nofollow noopener">java.net</a>.*;</p>
<p>public class Physics {</p>
<p>/** Offset into byte array of the type of service header value. */<br>
public static final int OFFSET_TYPE_OF_SERVICE = 1;</p>
<p>/** Offset into byte array of total packet length header value. */<br>
public static final int OFFSET_TOTAL_LENGTH = 2;</p>
<p>/** Offset into byte array of the identification header value. */<br>
public static final int OFFSET_IDENTIFICATION = 4;</p>
<p>/** Offset into byte array of the flags header value. */<br>
public static final int OFFSET_FLAGS = 6;</p>
<p>/** Offset into byte array of source address header value. */<br>
public static final int OFFSET_SOURCE_ADDRESS      = 12;</p>
<p>/** Number of bytes in source address. */<br>
public static final int LENGTH_SOURCE_ADDRESS      = 4;</p>
<p>/** Offset into byte array of destination address header value. */<br>
public static final int OFFSET_DESTINATION_ADDRESS = 16;</p>
<p>/** Number of bytes in destination address. */<br>
public static final int LENGTH_DESTINATION_ADDRESS = 4;</p>
<p>/** Offset into byte array of time to live header value. */<br>
public static final int OFFSET_TTL      = 8;</p>
<p>/** Offset into byte array of protocol number header value. */<br>
public static final int OFFSET_PROTOCOL = 9;</p>
<p>/** Offset into byte array of header checksum header value. */<br>
public static final int OFFSET_IP_CHECKSUM = 10;</p>
<p>/** Protocol constant for IPv4. */<br>
public static final int PROTOCOL_IP   = 0;</p>
<p>/** Protocol constant for ICMP. */<br>
public static final int PROTOCOL_ICMP = 1;</p>
<p>/** Protocol constant for TCP. */<br>
public static final int PROTOCOL_TCP  = 6;</p>
<p>/** Protocol constant for UDP. */<br>
public static final int PROTOCOL_UDP  = 17;</p>
<p>/** Raw packet data. */<br>
protected byte[] <em>data</em>;</p>
<p>public Physics(int size) {<br>
setData(new byte[size]);<br>
}</p>
<p>public int size() {<br>
return <em>data</em>.length;<br>
}</p>
<p>public void setData(byte[] data) {<br>
<em>data</em> = data;<br>
}</p>
<p>public void getData(byte[] data) {<br>
System.arraycopy(<em>data</em>, 0, data, 0, data.length);<br>
}</p>
<p>public final void copy(Physics packet) {<br>
if(<em>data</em>.length != packet.size())<br>
setData(new byte[packet.size()]);<br>
System.arraycopy(packet.<em>data</em>, 0, <em>data</em>, 0, <em>data</em>.length);<br>
}</p>
<p>public final void setIPVersion(int version) {<br>
<em>data</em>[0] &amp;= 0x0f;<br>
<em>data</em>[0] |= ((version &lt;&lt; 4) &amp; 0xf0);<br>
}</p>
<p>public final int getIPVersion() {<br>
return ((<em>data</em>[0] &amp; 0xf0) &gt;&gt; 4);<br>
}</p>
<p>public void setIPHeaderLength(int length) {<br>
// Clear low order bits and then set<br>
<em>data</em>[0] &amp;= 0xf0;<br>
<em>data</em>[0] |= (length &amp; 0x0f);<br>
}</p>
<p>public final int getIPHeaderLength() {<br>
return (<em>data</em>[0] &amp; 0x0f);<br>
}</p>
<p>public final int getIPHeaderByteLength() {<br>
return getIPHeaderLength() &lt;&lt; 2;<br>
}</p>
<p>public final void setTypeOfService(int service) {<br>
<em>data</em>[OFFSET_TYPE_OF_SERVICE] = (byte)(service &amp; 0xff);<br>
}</p>
<p>public final int getTypeOfService() {<br>
return (<em>data</em>[OFFSET_TYPE_OF_SERVICE] &amp; 0xff);<br>
}</p>
<p>public final void setIPPacketLength(int length) {<br>
<em>data</em>[OFFSET_TOTAL_LENGTH]     = (byte)((length &gt;&gt; 8) &amp; 0xff);<br>
<em>data</em>[OFFSET_TOTAL_LENGTH + 1] = (byte)(length &amp; 0xff);<br>
}</p>
<p>public final int getIPPacketLength() {<br>
return (((<em>data</em>[OFFSET_TOTAL_LENGTH] &amp; 0xff) &lt;&lt; 8) |<br>
(<em>data</em>[OFFSET_TOTAL_LENGTH + 1] &amp; 0xff));<br>
}</p>
<p>public void setIdentification(int id) {<br>
<em>data</em>[OFFSET_IDENTIFICATION]     = (byte)((id &gt;&gt; 8) &amp; 0xff);<br>
<em>data</em>[OFFSET_IDENTIFICATION + 1] = (byte)(id &amp; 0xff);<br>
}</p>
<p>public final int getIdentification() {<br>
return (((<em>data</em>[OFFSET_IDENTIFICATION] &amp; 0xff) &lt;&lt; 8) |<br>
(<em>data</em>[OFFSET_IDENTIFICATION + 1] &amp; 0xff));<br>
}</p>
<p>public final void setIPFlags(int flags) {<br>
<em>data</em>[OFFSET_FLAGS] &amp;= 0x1f;<br>
<em>data</em>[OFFSET_FLAGS] |= ((flags &lt;&lt; 5) &amp; 0xe0);<br>
}</p>
<p>public final int getIPFlags() {<br>
return ((<em>data</em>[OFFSET_FLAGS] &amp; 0xe0) &gt;&gt; 5);<br>
}</p>
<p>public void setFragmentOffset(int offset) {<br>
<em>data</em>[OFFSET_FLAGS] &amp;= 0xe0;<br>
<em>data</em>[OFFSET_FLAGS] |= ((offset &gt;&gt; 8) &amp; 0x1f);<br>
<em>data</em>[OFFSET_FLAGS + 1] = (byte)(offset &amp; 0xff);<br>
}</p>
<p>public final int getFragmentOffset() {<br>
return (((<em>data</em>[OFFSET_FLAGS] &amp; 0x1f) &lt;&lt; 8) |<br>
(<em>data</em>[OFFSET_FLAGS + 1] &amp; 0xff));<br>
}</p>
<p>public final void setProtocol(int protocol) {<br>
<em>data</em>[OFFSET_PROTOCOL] = (byte)protocol;<br>
}</p>
<p>public final int getProtocol() {<br>
return <em>data</em>[OFFSET_PROTOCOL];<br>
}</p>
<p>/**</p>
<ul>
<li>Sets the time to live value in seconds.</li>
<li>
</li>
<li>
<a class="mention" href="/u/param">@param</a> ttl The time to live value in seconds.<br>
*/<br>
public final void setTTL(int ttl) {<br>
<em>data</em>[OFFSET_TTL] = (byte)(ttl &amp; 0xff);<br>
}</li>
</ul>
<p>public final int getTTL() {<br>
return (<em>data</em>[OFFSET_TTL] &amp; 0xff);<br>
}</p>
<p>protected int <em>computeChecksum</em>(int startOffset,<br>
int checksumOffset,<br>
int length,<br>
int virtualHeaderTotal,<br>
boolean update)<br>
{<br>
int total = 0;<br>
int i     = startOffset;<br>
int imax  = checksumOffset;</p>
<pre><code>while(i &lt; imax)
  total+=(((_data_[i++] &amp; 0xff) &lt;&lt; 8) | (_data_[i++] &amp; 0xff));

// Skip existing checksum.
i = checksumOffset + 2;

imax = length - (length % 2);

while(i &lt; imax)
  total+=(((_data_[i++] &amp; 0xff) &lt;&lt; 8) | (_data_[i++] &amp; 0xff));

if(i &lt; length)
  total+=((_data_[i] &amp; 0xff) &lt;&lt; 8);

total+=virtualHeaderTotal;

// Fold to 16 bits
while((total &amp; 0xffff0000) != 0)
  total = (total &amp; 0xffff) + (total &gt;&gt;&gt; 16);

total = (~total &amp; 0xffff);

if(update) {
  _data_[checksumOffset]     = (byte)(total &gt;&gt; 8);
  _data_[checksumOffset + 1] = (byte)(total &amp; 0xff);
}

return total;
</code></pre>
<p>}</p>
<p>public final int computeIPChecksum(boolean update) {<br>
return <em>computeChecksum</em>(0, OFFSET_IP_CHECKSUM, getIPHeaderByteLength(),<br>
0, update);<br>
}</p>
<p>public final int computeIPChecksum() {<br>
return computeIPChecksum(true);<br>
}</p>
<p>public final int getIPChecksum() {<br>
return (((<em>data</em>[OFFSET_IP_CHECKSUM] &amp; 0xff) &lt;&lt; 8) |<br>
(<em>data</em>[OFFSET_IP_CHECKSUM + 1] &amp; 0xff));<br>
}</p>
<p>public final void getSource(StringBuffer buf) {<br>
System.arraycopy(<em>data</em>, OFFSET_SOURCE_ADDRESS, buf,<br>
0, (buf.length() &lt; LENGTH_SOURCE_ADDRESS ?<br>
buf.length() : LENGTH_SOURCE_ADDRESS));<br>
}</p>
<p>public final void getDestination(StringBuffer buf) {<br>
System.arraycopy(<em>data</em>, OFFSET_DESTINATION_ADDRESS, buf,<br>
0, (buf.length() &lt; LENGTH_DESTINATION_ADDRESS ?<br>
buf.length() : LENGTH_DESTINATION_ADDRESS));<br>
}</p>
<p>public final InetAddress getSourceAsInetAddress()<br>
throws UnknownHostException<br>
{<br>
StringBuffer buf = new StringBuffer();<br>
getSource(buf);<br>
return InetAddress.getByName(buf.toString());<br>
// This works only with JDK 1.4 and up<br>
/*<br>
byte[] octets = new byte[4];<br>
getSource(octets);<br>
return InetAddress.getByAddress(octets);<br>
<em>/<br>
}<br>
public final InetAddress getDestinationAsInetAddress()<br>
throws UnknownHostException<br>
{<br>
StringBuffer buf = new StringBuffer();<br>
getDestination(buf);<br>
return InetAddress.getByName(buf.toString());<br>
// This works only with JDK 1.4 and up<br>
/</em><br>
byte[] octets = new byte[4];<br>
getDestination(octets);<br>
return InetAddress.getByAddress(octets);<br>
*/<br>
}</p>
<p>public static void main (String[] args) {<br>
System.out.println("ip sum packet " + OFFSET_IP_CHECKSUM);<br>
System.out.println("ip adress packet " + PROTOCOL_IP);<br>
System.out.println("tcp packet " + PROTOCOL_TCP);<br>
System.out.println("icmp packet " +  PROTOCOL_ICMP);<br>
System.out.println("udp packet " + PROTOCOL_UDP);</p>
<p>}<br>
}[/code]</p>
<p>you’ll then have to:</p>
<p>[ul][li]Retrieve the source IP address as a string into a StringBuffer[/li]<br>
[li]Retrieve the destination IP address as a string into a StringBuffer[/li]<br>
[li]Set the source IP address using a word representation[/li]<br>
[li]Set the destination IP address using a word representation[/li]<br>
[li]Return The source IP address as a 32-bit word[/li]<br>
[li]Return The destination IP address as a 32-bit word[/li][/ul]</p>
<p>would their be any other ways of handling ip packets?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/ip-packets/429565/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/ip-packets/429565/1</link>
        <pubDate>Mon, 16 Jan 2012 21:17:27 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-429565-1</guid>
        <source url="https://forum.moparisthebest.com/t/ip-packets/429565.rss">Ip packets</source>
      </item>
  </channel>
</rss>
